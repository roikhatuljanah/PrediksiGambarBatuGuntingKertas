# -*- coding: utf-8 -*-
"""Sip.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GFS9WvnS2e2rVNLMFX5MBM26b5d8bxOD

#personal information

Nama: [Roikhatul Janah]

Email: [roikhatuljanah0302@gmail.com]

ID Dicoding: [roikhatul]
"""

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
import matplotlib.pyplot as plt
import numpy as np
import os
import shutil

# Download dataset
!wget https://github.com/dicodingacademy/assets/releases/download/release/rockpaperscissors.zip
!unzip rockpaperscissors.zip

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import os

# Tentukan direktori dataset
base_dir = 'rockpaperscissors'

# Buat list kelas yang diinginkan
valid_classes = ['rock', 'paper', 'scissors']

# Fungsi untuk memfilter kelas yang tidak diinginkan
def class_filter(class_subdirectory):
    return class_subdirectory in valid_classes

# Buat ImageDataGenerator dengan validation_split
datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    validation_split=0.4  # 40% untuk validasi
)

# Persiapkan generator untuk data training
train_generator = datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='training',
    classes=valid_classes  # Hanya gunakan kelas yang valid
)

# Persiapkan generator untuk data validasi
validation_generator = datagen.flow_from_directory(
    base_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical',
    subset='validation',
    classes=valid_classes  # Hanya gunakan kelas yang valid
)

print("Jumlah sampel training:", train_generator.n)
print("Jumlah sampel validasi:", validation_generator.n)

# Periksa urutan kelas
print("Class indices:", train_generator.class_indices)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(150, 150, 3)),
    MaxPooling2D(2,2),
    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Conv2D(128, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Conv2D(128, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Flatten(),
    Dropout(0.5),
    Dense(512, activation='relu'),
    Dense(3, activation='softmax')
])

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.n // 32,
    epochs=15,
    validation_data=validation_generator,
    validation_steps=validation_generator.n // 32
)

import matplotlib.pyplot as plt

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(acc))

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(epochs, acc, 'r', label='Training accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
plt.title('Training and Validation Accuracy')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(epochs, loss, 'r', label='Training Loss')
plt.plot(epochs, val_loss, 'b', label='Validation Loss')
plt.title('Training and Validation Loss')
plt.legend()

plt.show()

print("Class indices:", train_generator.class_indices)

import numpy as np

def predict_image(img_path):
    img = tf.keras.preprocessing.image.load_img(img_path, target_size=(150, 150))
    img_array = tf.keras.preprocessing.image.img_to_array(img)
    img_array = tf.expand_dims(img_array, 0)
    img_array /= 255.0

    predictions = model.predict(img_array)
    class_names = ['Rock', 'Paper', 'Scissors']
    predicted_class = class_names[np.argmax(predictions[0])]
    confidence = round(100 * np.max(predictions[0]), 2)

    plt.figure(figsize=(6, 6))
    plt.imshow(img)
    plt.title(f"Prediction: {predicted_class} ({confidence}%)")
    plt.axis('off')
    plt.show()

    print(f"This image most likely belongs to {predicted_class} with a {confidence}% confidence.")

import matplotlib.pyplot as plt

def show_batch(image_batch, label_batch):
    plt.figure(figsize=(10,10))
    for n in range(25):
        ax = plt.subplot(5,5,n+1)
        plt.imshow(image_batch[n])
        plt.title(class_names[label_batch[n].argmax()])
        plt.axis('off')
    plt.tight_layout()
    plt.show()

class_names = ['Rock', 'Paper', 'Scissors']  # Sesuaikan dengan urutan di class_indices
image_batch, label_batch = next(train_generator)
show_batch(image_batch, label_batch)

import numpy as np

def predict_and_plot(img_path):
    img = tf.keras.preprocessing.image.load_img(img_path, target_size=(150, 150))
    img_array = tf.keras.preprocessing.image.img_to_array(img)
    img_array = tf.expand_dims(img_array, 0)
    img_array /= 255.0

    predictions = model.predict(img_array)
    class_names = ['Rock', 'Paper', 'Scissors']  # Pastikan urutan ini sesuai dengan class_indices
    predicted_class = class_names[np.argmax(predictions[0])]
    confidence = round(100 * np.max(predictions[0]), 2)

    plt.figure(figsize=(6, 6))
    plt.imshow(img)
    plt.title(f"Prediction: {predicted_class} ({confidence}%)")
    plt.axis('off')
    plt.show()

    print(f"Predicted class: {predicted_class}")
    print(f"Confidence: {confidence}%")
    print("Class probabilities:")
    for i, prob in enumerate(predictions[0]):
        print(f"{class_names[i]}: {round(100 * prob, 2)}%")

# Ganti path sesuai dengan lokasi gambar validasi Anda
predict_and_plot('/content/rockpaperscissors/rock/00nKV8oHuTGi20gq.png')
predict_and_plot('/content/rockpaperscissors/paper/04l5I8TqdzF9WDMJ.png')
predict_and_plot('/content/rockpaperscissors/scissors/0ePX1wuCc3et7leL.png')

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# %matplotlib inline

def predict_uploaded_images():
    uploaded = files.upload()

    for fn in uploaded.keys():
        # Memuat dan menampilkan gambar
        path = fn
        img = image.load_img(path, target_size=(150, 150))

        plt.figure(figsize=(6, 6))
        plt.imshow(img)
        plt.axis('off')

        # Memproses gambar untuk prediksi
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        x = x / 255.0  # Normalisasi

        # Melakukan prediksi
        classes = model.predict(x)
        class_names = ['Rock', 'Paper', 'Scissors']
        predicted_class = class_names[np.argmax(classes[0])]
        confidence = round(100 * np.max(classes[0]), 2)

        # Menampilkan hasil prediksi
        plt.title(f"Prediction: {predicted_class} ({confidence}%)")
        plt.show()

        print(f"File: {fn}")
        print(f"Predicted class: {predicted_class}")
        print(f"Confidence: {confidence}%")
        print("---")

# Panggil fungsi untuk memulai upload dan prediksi
predict_uploaded_images()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# %matplotlib inline

def predict_uploaded_images():
    uploaded = files.upload()

    for fn in uploaded.keys():
        # Memuat dan menampilkan gambar
        path = fn
        img = image.load_img(path, target_size=(150, 150))

        plt.figure(figsize=(6, 6))
        plt.imshow(img)
        plt.axis('off')

        # Memproses gambar untuk prediksi
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        x = x / 255.0  # Normalisasi

        # Melakukan prediksi
        classes = model.predict(x)
        class_names = ['Rock', 'Paper', 'Scissors']
        predicted_class = class_names[np.argmax(classes[0])]
        confidence = round(100 * np.max(classes[0]), 2)

        # Menampilkan hasil prediksi
        plt.title(f"Prediction: {predicted_class} ({confidence}%)")
        plt.show()

        print(f"File: {fn}")
        print(f"Predicted class: {predicted_class}")
        print(f"Confidence: {confidence}%")
        print("---")

# Panggil fungsi untuk memulai upload dan prediksi
predict_uploaded_images()

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# %matplotlib inline

def predict_uploaded_images():
    uploaded = files.upload()

    for fn in uploaded.keys():
        # Memuat dan menampilkan gambar
        path = fn
        img = image.load_img(path, target_size=(150, 150))

        plt.figure(figsize=(6, 6))
        plt.imshow(img)
        plt.axis('off')

        # Memproses gambar untuk prediksi
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        x = x / 255.0  # Normalisasi

        # Melakukan prediksi
        classes = model.predict(x)
        class_names = ['Rock', 'Paper', 'Scissors']
        predicted_class = class_names[np.argmax(classes[0])]
        confidence = round(100 * np.max(classes[0]), 2)

        # Menampilkan hasil prediksi
        plt.title(f"Prediction: {predicted_class} ({confidence}%)")
        plt.show()

        print(f"File: {fn}")
        print(f"Predicted class: {predicted_class}")
        print(f"Confidence: {confidence}%")
        print("---")

# Panggil fungsi untuk memulai upload dan prediksi
predict_uploaded_images()